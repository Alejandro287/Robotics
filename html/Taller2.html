
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Taller2</title><meta name="generator" content="MATLAB 9.2"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2018-04-01"><meta name="DC.source" content="Taller2.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1></h1><!--introduction--><!--/introduction--><pre class="codeinput"><span class="comment">%Punto 2</span>

clear <span class="string">all</span>
clc

q1=0;
q2=0;

P2=[0    0      q1    0    0    1;
    0    pi/2   q2    0    0    1];


[Robot,L,A0N] = ForKin(P2);

fprintf(<span class="string">'\n\n Evaluacion de A0N con vector  de variables Q = [q1 q2 ... qn] \n'</span>)
Q = zeros(1,Robot.n)
evaluar(A0N, Q);
graficar (Robot,L, Q, 3, 3, 7)

disp(<span class="string">'PULSA CUALQUIER TECLA PARA CONTINUAR'</span>);
<span class="comment">%%pause ()</span>
</pre><img vspace="5" hspace="5" src="Taller2_01.png" alt=""> <pre class="codeinput"><span class="comment">%Punto 3</span>

clear <span class="string">all</span>
clc

q1=0;
q2=0;
q3=0;

P3=[0    0       0     q1    0    0;
    0    pi/2    q2    0     0    1;
    0    pi/2    0     q3    0    0];


[Robot,L,A0N] = ForKin(P3);

fprintf(<span class="string">'\n\n Evaluacion de A0N con vector de variables Q = [q1 q2 ... qn] \n'</span>)
Q = zeros(1,Robot.n)
evaluar(A0N, Q);
graficar (Robot,L, Q, 3, 3, 7)

disp(<span class="string">'PULSA CUALQUIER TECLA PARA CONTINUAR'</span>);
<span class="comment">%pause ()</span>
</pre><pre class="codeoutput"> 
Robot = 
 
Robot (3 axis, RPR, modDH, fastRNE)                              
                                                                 
+---+-----------+-----------+-----------+-----------+-----------+
| j |     theta |         d |         a |     alpha |    offset |
+---+-----------+-----------+-----------+-----------+-----------+
|  1|         q1|          0|          0|          0|          0|
|  2|          0|         q2|          0|      1.571|          0|
|  3|         q3|          0|          0|      1.571|          0|
+---+-----------+-----------+-----------+-----------+-----------+
                                                                 
grav =    0  base = 1  0  0  0   tool =  1  0  0  0              
          0         0  1  0  0           0  1  0  0              
       9.81         0  0  1  0           0  0  1  0              
                    0  0  0  1           0  0  0  1              
 
 
A01 =
 
[ cos(q1), -1.0*sin(q1),   0,   0]
[ sin(q1),      cos(q1),   0,   0]
[       0,            0, 1.0,   0]
[       0,            0,   0, 1.0]
 
 
A12 =
 
[ 1.0,   0,    0,       0]
[   0,   0, -1.0, -1.0*q2]
[   0, 1.0,    0,       0]
[   0,   0,    0,     1.0]
 
 
A23 =
 
[ cos(q3), -1.0*sin(q3),    0,   0]
[       0,            0, -1.0,   0]
[ sin(q3),      cos(q3),    0,   0]
[       0,            0,    0, 1.0]
 
 
A03 =
 
[ cos(q1 - 1.0*q3),      sin(q1 - 1.0*q3),    0,      q2*sin(q1)]
[ sin(q1 - 1.0*q3), -1.0*cos(q1 - 1.0*q3),    0, -1.0*q2*cos(q1)]
[                0,                     0, -1.0,               0]
[                0,                     0,    0,             1.0]
 


Posici&oacute;n en coordenadas Cartesianas: Pos = [x y z]'
 
Pos =
 
      q2*sin(q1)
 -1.0*q2*cos(q1)
               0
 


Orientaci&oacute;n en angulos fijos tipo XYZ: fijXYZ = [alpha beta gamma]
 
r31 =
 
0
 
 
r11 =
 
cos(q1 - 1.0*q3)
 
 
r21 =
 
sin(q1 - 1.0*q3)
 
 
r32 =
 
0
 
 
r33 =
 
-1.0
 
beta = atan2(-r31,sqrt((r11^2)+(r(21^2))))

alpha = atan2(r32/cos(B),r33/cos(B))

gamma = atan2(r21/cos(B),r11/cos(B))



Orientacion en angulos de Euler tipo XYZ: eulXYZ = [alpha beta gamma]
 
r13 =
 
0
 
 
r23 =
 
0
 
 
r33 =
 
-1.0
 
 
r12 =
 
sin(q1 - 1.0*q3)
 
 
r11 =
 
cos(q1 - 1.0*q3)
 
beta = atan2(r13,sqrt((r23^2)+(r(33^2))))

alpha = atan2(-r23/cos(B),r33/cos(B))

gamma = atan2(-r12/cos(B),r11/cos(B))



 Evaluacion de A0N con vector de variables Q = [q1 q2 ... qn] 

Q =

     0     0     0


T =

     1     0     0     0
     0    -1     0     0
     0     0    -1     0
     0     0     0     1



Posici&oacute;n en coordenadas Cartesianas: Pos = [x y z]
 
Pos =
 
[ 0, 0, 0]
 


Matriz de rotaci&oacute;n:

r =

     1     0     0
     0    -1     0
     0     0    -1



Orientacion en angulos fijos tipo XYZ: fijXYZ = [alpha beta gamma]
    3.1416         0         0



Orientacion en angulos de Euler tipo XYZ: eulXYZ = [alpha beta gamma]
   -3.1416         0         0



Orientacion en angulos de Euler tipo ZYZ: eulZYZ = [alpha beta gamma]
         0    3.1416    3.1416

PULSA CUALQUIER TECLA PARA CONTINUAR
</pre><img vspace="5" hspace="5" src="Taller2_02.png" alt=""> <pre class="codeinput"><span class="comment">%Punto 4</span>

clear <span class="string">all</span>
clc

q1=0;
q2=0;
q3=0;
q4=0;
q5=0;

P4=[0           0      1          q1    0      0;
    0           pi/2   q2         0     1      1;
    0           pi/2   1          q3    pi/2   0;
    0          -pi/2   0          q4    pi/4   0;
    sqrt(2)/2   pi/2   sqrt(2)/2  q5   -pi/2   0;
    0          -pi/2   sqrt(2)    0     0     -1];


[Robot,L,A0N] = ForKin(P4);

fprintf(<span class="string">'\n\n Evaluacion de A0N con vector de variables Q = [q1 q2 ... qn] \n'</span>)
Q = zeros(1,Robot.n)
evaluar(A0N, Q);
graficar (Robot,L, Q, 5, 3, 8)

disp(<span class="string">'PULSA CUALQUIER TECLA PARA CONTINUAR'</span>);
<span class="comment">%pause ()</span>
</pre><pre class="codeoutput"> 
Robot = 
 
Robot (5 axis, RPRRR, modDH, fastRNE)                                         
                                                                              
+---+-----------+-----------+-----------+-----------+-----------+             
| j |     theta |         d |         a |     alpha |    offset |             
+---+-----------+-----------+-----------+-----------+-----------+             
|  1|         q1|          1|          0|          0|          0|             
|  2|          0|         q2|          0|      1.571|          1|             
|  3|         q3|          1|          0|      1.571|      1.571|             
|  4|         q4|          0|          0|     -1.571|     0.7854|             
|  5|         q5|     0.7071|     0.7071|      1.571|     -1.571|             
+---+-----------+-----------+-----------+-----------+-----------+             
                                                                              
grav =    0  base = 1  0  0  0   tool =  1           0           0           0
          0         0  1  0  0           0           0           1      1.4142
       9.81         0  0  1  0           0          -1           0           0
                    0  0  0  1           0           0           0           1
 
 
A01 =
 
[ cos(q1), -1.0*sin(q1),   0,   0]
[ sin(q1),      cos(q1),   0,   0]
[       0,            0, 1.0, 1.0]
[       0,            0,   0, 1.0]
 
 
A12 =
 
[ 1.0,   0,    0,              0]
[   0,   0, -1.0, - 1.0*q2 - 1.0]
[   0, 1.0,    0,              0]
[   0,   0,    0,            1.0]
 
 
A23 =
 
[ -1.0*sin(q3), -1.0*cos(q3),    0,    0]
[            0,            0, -1.0, -1.0]
[      cos(q3), -1.0*sin(q3),    0,    0]
[            0,            0,    0,  1.0]
 
 
A34 =
 
[      cos(q4 + 0.7854), -1.0*sin(q4 + 0.7854),   0,   0]
[                     0,                     0, 1.0,   0]
[ -1.0*sin(q4 + 0.7854), -1.0*cos(q4 + 0.7854),   0,   0]
[                     0,                     0,   0, 1.0]
 
 
A45 =
 
[      sin(q5), cos(q5),    0,  0.70711]
[            0,       0, -1.0, -0.70711]
[ -1.0*cos(q5), sin(q5),    0,        0]
[            0,       0,    0,      1.0]
 
 
A56 =
 
[ 1.0,    0,   0,      0]
[   0,    0, 1.0, 1.4142]
[   0, -1.0,   0,      0]
[   0,    0,   0,    1.0]
 
 
A06 =
 
[     cos(q1 - 1.0*q3)*cos(q5) + sin(q1 - 1.0*q3)*cos(q4 + 0.7854)*sin(q5), -1.0*sin(q1 - 1.0*q3)*sin(q4 + 0.7854),       sin(q1 - 1.0*q3)*cos(q4 + 0.7854)*cos(q5) - 1.0*cos(q1 - 1.0*q3)*sin(q5),   0.70711*sin(q1 - 1.0*q3)*cos(q4 + 0.7854) + 1.0*sin(q1)*(q2 + 1.0) + 0.70711*sin(q1 - 1.0*q3)*sin(q4 + 0.7854) - 1.4142*cos(q1 - 1.0*q3)*sin(q5) + 1.4142*sin(q1 - 1.0*q3)*cos(q4 + 0.7854)*cos(q5)]
[ sin(q1 - 1.0*q3)*cos(q5) - 1.0*cos(q1 - 1.0*q3)*cos(q4 + 0.7854)*sin(q5),      cos(q1 - 1.0*q3)*sin(q4 + 0.7854), - 1.0*sin(q1 - 1.0*q3)*sin(q5) - 1.0*cos(q1 - 1.0*q3)*cos(q4 + 0.7854)*cos(q5), - 0.70711*cos(q1 - 1.0*q3)*cos(q4 + 0.7854) - 1.0*cos(q1)*(q2 + 1.0) - 0.70711*cos(q1 - 1.0*q3)*sin(q4 + 0.7854) - 1.4142*sin(q1 - 1.0*q3)*sin(q5) - 1.4142*cos(q1 - 1.0*q3)*cos(q4 + 0.7854)*cos(q5)]
[                                                 sin(q4 + 0.7854)*sin(q5),                       cos(q4 + 0.7854),                                                       sin(q4 + 0.7854)*cos(q5),                                                                                                                                                1.4142*sin(q4 + 0.7854)*cos(q5) - 1.0*cos(q4 + 1.5708)]
[                                                                        0,                                      0,                                                                              0,                                                                                                                                                                                                   1.0]
 


Posici&oacute;n en coordenadas Cartesianas: Pos = [x y z]'
 
Pos =
 
   0.70711*sin(q1 - 1.0*q3)*cos(q4 + 0.7854) + 1.0*sin(q1)*(q2 + 1.0) + 0.70711*sin(q1 - 1.0*q3)*sin(q4 + 0.7854) - 1.4142*cos(q1 - 1.0*q3)*sin(q5) + 1.4142*sin(q1 - 1.0*q3)*cos(q4 + 0.7854)*cos(q5)
 - 0.70711*cos(q1 - 1.0*q3)*cos(q4 + 0.7854) - 1.0*cos(q1)*(q2 + 1.0) - 0.70711*cos(q1 - 1.0*q3)*sin(q4 + 0.7854) - 1.4142*sin(q1 - 1.0*q3)*sin(q5) - 1.4142*cos(q1 - 1.0*q3)*cos(q4 + 0.7854)*cos(q5)
                                                                                                                                                1.4142*sin(q4 + 0.7854)*cos(q5) - 1.0*cos(q4 + 1.5708)
 


Orientaci&oacute;n en angulos fijos tipo XYZ: fijXYZ = [alpha beta gamma]
 
r31 =
 
sin(q4 + 0.7854)*sin(q5)
 
 
r11 =
 
cos(q1 - 1.0*q3)*cos(q5) + sin(q1 - 1.0*q3)*cos(q4 + 0.7854)*sin(q5)
 
 
r21 =
 
sin(q1 - 1.0*q3)*cos(q5) - 1.0*cos(q1 - 1.0*q3)*cos(q4 + 0.7854)*sin(q5)
 
 
r32 =
 
cos(q4 + 0.7854)
 
 
r33 =
 
sin(q4 + 0.7854)*cos(q5)
 
beta = atan2(-r31,sqrt((r11^2)+(r(21^2))))

alpha = atan2(r32/cos(B),r33/cos(B))

gamma = atan2(r21/cos(B),r11/cos(B))



Orientacion en angulos de Euler tipo XYZ: eulXYZ = [alpha beta gamma]
 
r13 =
 
sin(q1 - 1.0*q3)*cos(q4 + 0.7854)*cos(q5) - 1.0*cos(q1 - 1.0*q3)*sin(q5)
 
 
r23 =
 
- 1.0*sin(q1 - 1.0*q3)*sin(q5) - 1.0*cos(q1 - 1.0*q3)*cos(q4 + 0.7854)*cos(q5)
 
 
r33 =
 
sin(q4 + 0.7854)*cos(q5)
 
 
r12 =
 
-1.0*sin(q1 - 1.0*q3)*sin(q4 + 0.7854)
 
 
r11 =
 
cos(q1 - 1.0*q3)*cos(q5) + sin(q1 - 1.0*q3)*cos(q4 + 0.7854)*sin(q5)
 
beta = atan2(r13,sqrt((r23^2)+(r(33^2))))

alpha = atan2(-r23/cos(B),r33/cos(B))

gamma = atan2(-r12/cos(B),r11/cos(B))



 Evaluacion de A0N con vector de variables Q = [q1 q2 ... qn] 

Q =

     0     0     0     0     0


T =

    1.0000         0         0         0
         0    0.7071   -0.7071   -3.0000
         0    0.7071    0.7071    1.0000
         0         0         0    1.0000



Posici&oacute;n en coordenadas Cartesianas: Pos = [x y z]
 
Pos =
 
[ 0, -3.0, 1.0]
 


Matriz de rotaci&oacute;n:

r =

    1.0000         0         0
         0    0.7071   -0.7071
         0    0.7071    0.7071



Orientacion en angulos fijos tipo XYZ: fijXYZ = [alpha beta gamma]
    0.7854         0         0



Orientacion en angulos de Euler tipo XYZ: eulXYZ = [alpha beta gamma]
    0.7854         0         0



Orientacion en angulos de Euler tipo ZYZ: eulZYZ = [alpha beta gamma]
   -1.5708    0.7854    1.5708

PULSA CUALQUIER TECLA PARA CONTINUAR
</pre><img vspace="5" hspace="5" src="Taller2_03.png" alt=""> <pre class="codeinput"><span class="comment">%Punto 5</span>

clear <span class="string">all</span>
clc

syms <span class="string">L1</span> <span class="string">L2</span> <span class="string">L3</span> <span class="string">L4</span> <span class="string">as</span> <span class="string">real</span>
syms <span class="string">q1</span> <span class="string">q2</span> <span class="string">q3</span> <span class="string">q4</span> <span class="string">q5</span> <span class="string">q6</span> <span class="string">as</span> <span class="string">real</span>


P5=[0    0      L1     q1   0     0;
    0    pi/2   0      q2   0     0;
    L2   0      0      q3   pi/2  0;
    0    pi/2   L3     q4   pi/2  0;
    0    pi/2   0      q5   0     0;
    0   -pi/2   0      q6   0     0;
    0    0      L4     0    0    -1];


[Robot,L,A0N] = ForKin(P5);

q1=0;
q2=0;
q3=0;
q4=0;
q5=0;
q6=0;

L1=40;
L2=30;
L3=50;
L4=30;

P5=eval(P5);

[Robot,L,A0N] = ForKin(P5);

fprintf(<span class="string">'\n\n Evaluacion de A0N con vector de variables Q = [q1 q2 ... qn] \n'</span>)
Q= zeros(1,Robot.n)
evaluar(A0N, Q);
graficar (Robot,L, Q, 5, 20, 10)

disp(<span class="string">'PULSA CUALQUIER TECLA PARA CONTINUAR'</span>);
<span class="comment">%pause ()</span>

fprintf(<span class="string">'\n\n Evaluacion de A0N con vector de variables Q = [q1 q2 ... qn] \n'</span>)
Q=[pi/6, -pi/6, -pi/12, -pi/2, pi, pi/2]
evaluar(A0N, Q);
graficar (Robot,L, Q, 5, 20, 10)

disp(<span class="string">'PULSA CUALQUIER TECLA PARA CONTINUAR'</span>);
<span class="comment">%pause ()</span>
</pre><pre class="codeoutput"> 
Robot = 
 
Robot (6 axis, RRRRRR, modDH, fastRNE)                           
                                                                 
+---+-----------+-----------+-----------+-----------+-----------+
| j |     theta |         d |         a |     alpha |    offset |
+---+-----------+-----------+-----------+-----------+-----------+
|  1|         q1|         L1|          0|          0|          0|
|  2|         q2|          0|          0|       pi/2|          0|
|  3|         q3|          0|         L2|          0|       pi/2|
|  4|         q4|         L3|          0|       pi/2|       pi/2|
|  5|         q5|          0|          0|       pi/2|          0|
|  6|         q6|          0|          0|      -pi/2|          0|
+---+-----------+-----------+-----------+-----------+-----------+
                                                                 
grav =    0  base = 1  0  0  0   tool =   1  0  0  0             
          0         0  1  0  0            0  1  0  0             
       9.81         0  0  1  0            0  0  1  L4            
                    0  0  0  1            0  0  0  1             
 
 
A01 =
 
[ cos(q1), -1.0*sin(q1),   0,   0]
[ sin(q1),      cos(q1),   0,   0]
[       0,            0, 1.0,  L1]
[       0,            0,   0, 1.0]
 
 
A12 =
 
[ cos(q2), -1.0*sin(q2),    0,   0]
[       0,            0, -1.0,   0]
[ sin(q2),      cos(q2),    0,   0]
[       0,            0,    0, 1.0]
 
 
A23 =
 
[ -1.0*sin(q3), -1.0*cos(q3),   0,  L2]
[      cos(q3), -1.0*sin(q3),   0,   0]
[            0,            0, 1.0,   0]
[            0,            0,   0, 1.0]
 
 
A34 =
 
[ -1.0*sin(q4), -1.0*cos(q4),    0,       0]
[            0,            0, -1.0, -1.0*L3]
[      cos(q4), -1.0*sin(q4),    0,       0]
[            0,            0,    0,     1.0]
 
 
A45 =
 
[ cos(q5), -1.0*sin(q5),    0,   0]
[       0,            0, -1.0,   0]
[ sin(q5),      cos(q5),    0,   0]
[       0,            0,    0, 1.0]
 
 
A56 =
 
[      cos(q6), -1.0*sin(q6),   0,   0]
[            0,            0, 1.0,   0]
[ -1.0*sin(q6), -1.0*cos(q6),   0,   0]
[            0,            0,   0, 1.0]
 
 
A67 =
 
[ 1.0,   0,   0,   0]
[   0, 1.0,   0,   0]
[   0,   0, 1.0,  L4]
[   0,   0,   0, 1.0]
 
 
A07 =
 
[                         cos(q6)*(cos(q5)*(cos(q4)*sin(q1) + sin(q2 + q3)*cos(q1)*sin(q4)) + cos(q2 + q3)*cos(q1)*sin(q5)) - 1.0*sin(q6)*(sin(q1)*sin(q4) - 1.0*sin(q2 + q3)*cos(q1)*cos(q4)),                   - 1.0*cos(q6)*(sin(q1)*sin(q4) - 1.0*sin(q2 + q3)*cos(q1)*cos(q4)) - 1.0*sin(q6)*(cos(q5)*(cos(q4)*sin(q1) + sin(q2 + q3)*cos(q1)*sin(q4)) + cos(q2 + q3)*cos(q1)*sin(q5)),         1.0*cos(q2 + q3)*cos(q1)*cos(q5) - 1.0*sin(q5)*(cos(q4)*sin(q1) + sin(q2 + q3)*cos(q1)*sin(q4)),     cos(q1)*(L3*cos(q2 + q3) + L2*cos(q2)) - 1.0*L4*(1.0*sin(q5)*(cos(q4)*sin(q1) + sin(q2 + q3)*cos(q1)*sin(q4)) - 1.0*cos(q2 + q3)*cos(q1)*cos(q5))]
[ 1.0*sin(q6)*(1.0*cos(q1)*sin(q4) + 1.0*sin(q2 + q3)*cos(q4)*sin(q1)) - 1.0*cos(q6)*(1.0*cos(q5)*(1.0*cos(q1)*cos(q4) - 1.0*sin(q2 + q3)*sin(q1)*sin(q4)) - 1.0*cos(q2 + q3)*sin(q1)*sin(q5)), 1.0*sin(q6)*(1.0*cos(q5)*(1.0*cos(q1)*cos(q4) - 1.0*sin(q2 + q3)*sin(q1)*sin(q4)) - 1.0*cos(q2 + q3)*sin(q1)*sin(q5)) + 1.0*cos(q6)*(1.0*cos(q1)*sin(q4) + 1.0*sin(q2 + q3)*cos(q4)*sin(q1)), 1.0*sin(q5)*(1.0*cos(q1)*cos(q4) - 1.0*sin(q2 + q3)*sin(q1)*sin(q4)) + 1.0*cos(q2 + q3)*cos(q5)*sin(q1), L4*(1.0*sin(q5)*(1.0*cos(q1)*cos(q4) - 1.0*sin(q2 + q3)*sin(q1)*sin(q4)) + 1.0*cos(q2 + q3)*cos(q5)*sin(q1)) + sin(q1)*(L3*cos(q2 + q3) + L2*cos(q2))]
[                                                                                         cos(q6)*(sin(q2 + q3)*sin(q5) - 1.0*cos(q2 + q3)*cos(q5)*sin(q4)) - 1.0*cos(q2 + q3)*cos(q4)*sin(q6),                                                                                   - 1.0*sin(q6)*(sin(q2 + q3)*sin(q5) - 1.0*cos(q2 + q3)*cos(q5)*sin(q4)) - 1.0*cos(q2 + q3)*cos(q4)*cos(q6),                                                     sin(q2 + q3)*cos(q5) + cos(q2 + q3)*sin(q4)*sin(q5),                                                          L1 + L3*sin(q2 + q3) + L2*sin(q2) + L4*(sin(q2 + q3)*cos(q5) + cos(q2 + q3)*sin(q4)*sin(q5))]
[                                                                                                                                                                                            0,                                                                                                                                                                                            0,                                                                                                       0,                                                                                                                                                   1.0]
 


Posici&oacute;n en coordenadas Cartesianas: Pos = [x y z]'
 
Pos =
 
     cos(q1)*(L3*cos(q2 + q3) + L2*cos(q2)) - 1.0*L4*(1.0*sin(q5)*(cos(q4)*sin(q1) + sin(q2 + q3)*cos(q1)*sin(q4)) - 1.0*cos(q2 + q3)*cos(q1)*cos(q5))
 L4*(1.0*sin(q5)*(1.0*cos(q1)*cos(q4) - 1.0*sin(q2 + q3)*sin(q1)*sin(q4)) + 1.0*cos(q2 + q3)*cos(q5)*sin(q1)) + sin(q1)*(L3*cos(q2 + q3) + L2*cos(q2))
                                                          L1 + L3*sin(q2 + q3) + L2*sin(q2) + L4*(sin(q2 + q3)*cos(q5) + cos(q2 + q3)*sin(q4)*sin(q5))
 


Orientaci&oacute;n en angulos fijos tipo XYZ: fijXYZ = [alpha beta gamma]
 
r31 =
 
cos(q6)*(sin(q2 + q3)*sin(q5) - 1.0*cos(q2 + q3)*cos(q5)*sin(q4)) - 1.0*cos(q2 + q3)*cos(q4)*sin(q6)
 
 
r11 =
 
cos(q6)*(cos(q5)*(cos(q4)*sin(q1) + sin(q2 + q3)*cos(q1)*sin(q4)) + cos(q2 + q3)*cos(q1)*sin(q5)) - 1.0*sin(q6)*(sin(q1)*sin(q4) - 1.0*sin(q2 + q3)*cos(q1)*cos(q4))
 
 
r21 =
 
1.0*sin(q6)*(1.0*cos(q1)*sin(q4) + 1.0*sin(q2 + q3)*cos(q4)*sin(q1)) - 1.0*cos(q6)*(1.0*cos(q5)*(1.0*cos(q1)*cos(q4) - 1.0*sin(q2 + q3)*sin(q1)*sin(q4)) - 1.0*cos(q2 + q3)*sin(q1)*sin(q5))
 
 
r32 =
 
- 1.0*sin(q6)*(sin(q2 + q3)*sin(q5) - 1.0*cos(q2 + q3)*cos(q5)*sin(q4)) - 1.0*cos(q2 + q3)*cos(q4)*cos(q6)
 
 
r33 =
 
sin(q2 + q3)*cos(q5) + cos(q2 + q3)*sin(q4)*sin(q5)
 
beta = atan2(-r31,sqrt((r11^2)+(r(21^2))))

alpha = atan2(r32/cos(B),r33/cos(B))

gamma = atan2(r21/cos(B),r11/cos(B))



Orientacion en angulos de Euler tipo XYZ: eulXYZ = [alpha beta gamma]
 
r13 =
 
1.0*cos(q2 + q3)*cos(q1)*cos(q5) - 1.0*sin(q5)*(cos(q4)*sin(q1) + sin(q2 + q3)*cos(q1)*sin(q4))
 
 
r23 =
 
1.0*sin(q5)*(1.0*cos(q1)*cos(q4) - 1.0*sin(q2 + q3)*sin(q1)*sin(q4)) + 1.0*cos(q2 + q3)*cos(q5)*sin(q1)
 
 
r33 =
 
sin(q2 + q3)*cos(q5) + cos(q2 + q3)*sin(q4)*sin(q5)
 
 
r12 =
 
- 1.0*cos(q6)*(sin(q1)*sin(q4) - 1.0*sin(q2 + q3)*cos(q1)*cos(q4)) - 1.0*sin(q6)*(cos(q5)*(cos(q4)*sin(q1) + sin(q2 + q3)*cos(q1)*sin(q4)) + cos(q2 + q3)*cos(q1)*sin(q5))
 
 
r11 =
 
cos(q6)*(cos(q5)*(cos(q4)*sin(q1) + sin(q2 + q3)*cos(q1)*sin(q4)) + cos(q2 + q3)*cos(q1)*sin(q5)) - 1.0*sin(q6)*(sin(q1)*sin(q4) - 1.0*sin(q2 + q3)*cos(q1)*cos(q4))
 
beta = atan2(r13,sqrt((r23^2)+(r(33^2))))

alpha = atan2(-r23/cos(B),r33/cos(B))

gamma = atan2(-r12/cos(B),r11/cos(B))

 
Robot = 
 
Robot (6 axis, RRRRRR, modDH, fastRNE)                           
                                                                 
+---+-----------+-----------+-----------+-----------+-----------+
| j |     theta |         d |         a |     alpha |    offset |
+---+-----------+-----------+-----------+-----------+-----------+
|  1|         q1|         40|          0|          0|          0|
|  2|         q2|          0|          0|      1.571|          0|
|  3|         q3|          0|         30|          0|      1.571|
|  4|         q4|         50|          0|      1.571|      1.571|
|  5|         q5|          0|          0|      1.571|          0|
|  6|         q6|          0|          0|     -1.571|          0|
+---+-----------+-----------+-----------+-----------+-----------+
                                                                 
grav =    0  base = 1  0  0  0   tool =  1   0   0   0           
          0         0  1  0  0           0   1   0   0           
       9.81         0  0  1  0           0   0   1  30           
                    0  0  0  1           0   0   0   1           
 
 
A01 =
 
[ cos(q1), -1.0*sin(q1),   0,    0]
[ sin(q1),      cos(q1),   0,    0]
[       0,            0, 1.0, 40.0]
[       0,            0,   0,  1.0]
 
 
A12 =
 
[ cos(q2), -1.0*sin(q2),    0,   0]
[       0,            0, -1.0,   0]
[ sin(q2),      cos(q2),    0,   0]
[       0,            0,    0, 1.0]
 
 
A23 =
 
[ -1.0*sin(q3), -1.0*cos(q3),   0, 30.0]
[      cos(q3), -1.0*sin(q3),   0,    0]
[            0,            0, 1.0,    0]
[            0,            0,   0,  1.0]
 
 
A34 =
 
[ -1.0*sin(q4), -1.0*cos(q4),    0,     0]
[            0,            0, -1.0, -50.0]
[      cos(q4), -1.0*sin(q4),    0,     0]
[            0,            0,    0,   1.0]
 
 
A45 =
 
[ cos(q5), -1.0*sin(q5),    0,   0]
[       0,            0, -1.0,   0]
[ sin(q5),      cos(q5),    0,   0]
[       0,            0,    0, 1.0]
 
 
A56 =
 
[      cos(q6), -1.0*sin(q6),   0,   0]
[            0,            0, 1.0,   0]
[ -1.0*sin(q6), -1.0*cos(q6),   0,   0]
[            0,            0,   0, 1.0]
 
 
A67 =
 
[ 1.0,   0,   0,    0]
[   0, 1.0,   0,    0]
[   0,   0, 1.0, 30.0]
[   0,   0,   0,  1.0]
 
 
A07 =
 
[                         cos(q6)*(cos(q5)*(cos(q4)*sin(q1) + sin(q2 + q3)*cos(q1)*sin(q4)) + cos(q2 + q3)*cos(q1)*sin(q5)) - 1.0*sin(q6)*(sin(q1)*sin(q4) - 1.0*sin(q2 + q3)*cos(q1)*cos(q4)),                   - 1.0*cos(q6)*(sin(q1)*sin(q4) - 1.0*sin(q2 + q3)*cos(q1)*cos(q4)) - 1.0*sin(q6)*(cos(q5)*(cos(q4)*sin(q1) + sin(q2 + q3)*cos(q1)*sin(q4)) + cos(q2 + q3)*cos(q1)*sin(q5)),         1.0*cos(q2 + q3)*cos(q1)*cos(q5) - 1.0*sin(q5)*(cos(q4)*sin(q1) + sin(q2 + q3)*cos(q1)*sin(q4)),         10.0*cos(q1)*(5.0*cos(q2 + q3) + 3.0*cos(q2)) - 30.0*sin(q5)*(cos(q4)*sin(q1) + sin(q2 + q3)*cos(q1)*sin(q4)) + 30.0*cos(q2 + q3)*cos(q1)*cos(q5)]
[ 1.0*sin(q6)*(1.0*cos(q1)*sin(q4) + 1.0*sin(q2 + q3)*cos(q4)*sin(q1)) - 1.0*cos(q6)*(1.0*cos(q5)*(1.0*cos(q1)*cos(q4) - 1.0*sin(q2 + q3)*sin(q1)*sin(q4)) - 1.0*cos(q2 + q3)*sin(q1)*sin(q5)), 1.0*sin(q6)*(1.0*cos(q5)*(1.0*cos(q1)*cos(q4) - 1.0*sin(q2 + q3)*sin(q1)*sin(q4)) - 1.0*cos(q2 + q3)*sin(q1)*sin(q5)) + 1.0*cos(q6)*(1.0*cos(q1)*sin(q4) + 1.0*sin(q2 + q3)*cos(q4)*sin(q1)), 1.0*sin(q5)*(1.0*cos(q1)*cos(q4) - 1.0*sin(q2 + q3)*sin(q1)*sin(q4)) + 1.0*cos(q2 + q3)*cos(q5)*sin(q1), 30.0*sin(q5)*(1.0*cos(q1)*cos(q4) - 1.0*sin(q2 + q3)*sin(q1)*sin(q4)) + 10.0*sin(q1)*(5.0*cos(q2 + q3) + 3.0*cos(q2)) + 30.0*cos(q2 + q3)*cos(q5)*sin(q1)]
[                                                                                         cos(q6)*(sin(q2 + q3)*sin(q5) - 1.0*cos(q2 + q3)*cos(q5)*sin(q4)) - 1.0*cos(q2 + q3)*cos(q4)*sin(q6),                                                                                   - 1.0*sin(q6)*(sin(q2 + q3)*sin(q5) - 1.0*cos(q2 + q3)*cos(q5)*sin(q4)) - 1.0*cos(q2 + q3)*cos(q4)*cos(q6),                                                     sin(q2 + q3)*cos(q5) + cos(q2 + q3)*sin(q4)*sin(q5),                                                   50.0*sin(q2 + q3) + 30.0*sin(q2) + 30.0*sin(q2 + q3)*cos(q5) + 30.0*cos(q2 + q3)*sin(q4)*sin(q5) + 40.0]
[                                                                                                                                                                                            0,                                                                                                                                                                                            0,                                                                                                       0,                                                                                                                                                       1.0]
 


Posici&oacute;n en coordenadas Cartesianas: Pos = [x y z]'
 
Pos =
 
         10.0*cos(q1)*(5.0*cos(q2 + q3) + 3.0*cos(q2)) - 30.0*sin(q5)*(cos(q4)*sin(q1) + sin(q2 + q3)*cos(q1)*sin(q4)) + 30.0*cos(q2 + q3)*cos(q1)*cos(q5)
 30.0*sin(q5)*(1.0*cos(q1)*cos(q4) - 1.0*sin(q2 + q3)*sin(q1)*sin(q4)) + 10.0*sin(q1)*(5.0*cos(q2 + q3) + 3.0*cos(q2)) + 30.0*cos(q2 + q3)*cos(q5)*sin(q1)
                                                   50.0*sin(q2 + q3) + 30.0*sin(q2) + 30.0*sin(q2 + q3)*cos(q5) + 30.0*cos(q2 + q3)*sin(q4)*sin(q5) + 40.0
 


Orientaci&oacute;n en angulos fijos tipo XYZ: fijXYZ = [alpha beta gamma]
 
r31 =
 
cos(q6)*(sin(q2 + q3)*sin(q5) - 1.0*cos(q2 + q3)*cos(q5)*sin(q4)) - 1.0*cos(q2 + q3)*cos(q4)*sin(q6)
 
 
r11 =
 
cos(q6)*(cos(q5)*(cos(q4)*sin(q1) + sin(q2 + q3)*cos(q1)*sin(q4)) + cos(q2 + q3)*cos(q1)*sin(q5)) - 1.0*sin(q6)*(sin(q1)*sin(q4) - 1.0*sin(q2 + q3)*cos(q1)*cos(q4))
 
 
r21 =
 
1.0*sin(q6)*(1.0*cos(q1)*sin(q4) + 1.0*sin(q2 + q3)*cos(q4)*sin(q1)) - 1.0*cos(q6)*(1.0*cos(q5)*(1.0*cos(q1)*cos(q4) - 1.0*sin(q2 + q3)*sin(q1)*sin(q4)) - 1.0*cos(q2 + q3)*sin(q1)*sin(q5))
 
 
r32 =
 
- 1.0*sin(q6)*(sin(q2 + q3)*sin(q5) - 1.0*cos(q2 + q3)*cos(q5)*sin(q4)) - 1.0*cos(q2 + q3)*cos(q4)*cos(q6)
 
 
r33 =
 
sin(q2 + q3)*cos(q5) + cos(q2 + q3)*sin(q4)*sin(q5)
 
beta = atan2(-r31,sqrt((r11^2)+(r(21^2))))

alpha = atan2(r32/cos(B),r33/cos(B))

gamma = atan2(r21/cos(B),r11/cos(B))



Orientacion en angulos de Euler tipo XYZ: eulXYZ = [alpha beta gamma]
 
r13 =
 
1.0*cos(q2 + q3)*cos(q1)*cos(q5) - 1.0*sin(q5)*(cos(q4)*sin(q1) + sin(q2 + q3)*cos(q1)*sin(q4))
 
 
r23 =
 
1.0*sin(q5)*(1.0*cos(q1)*cos(q4) - 1.0*sin(q2 + q3)*sin(q1)*sin(q4)) + 1.0*cos(q2 + q3)*cos(q5)*sin(q1)
 
 
r33 =
 
sin(q2 + q3)*cos(q5) + cos(q2 + q3)*sin(q4)*sin(q5)
 
 
r12 =
 
- 1.0*cos(q6)*(sin(q1)*sin(q4) - 1.0*sin(q2 + q3)*cos(q1)*cos(q4)) - 1.0*sin(q6)*(cos(q5)*(cos(q4)*sin(q1) + sin(q2 + q3)*cos(q1)*sin(q4)) + cos(q2 + q3)*cos(q1)*sin(q5))
 
 
r11 =
 
cos(q6)*(cos(q5)*(cos(q4)*sin(q1) + sin(q2 + q3)*cos(q1)*sin(q4)) + cos(q2 + q3)*cos(q1)*sin(q5)) - 1.0*sin(q6)*(sin(q1)*sin(q4) - 1.0*sin(q2 + q3)*cos(q1)*cos(q4))
 
beta = atan2(r13,sqrt((r23^2)+(r(33^2))))

alpha = atan2(-r23/cos(B),r33/cos(B))

gamma = atan2(-r12/cos(B),r11/cos(B))



 Evaluacion de A0N con vector de variables Q = [q1 q2 ... qn] 

Q =

     0     0     0     0     0     0


T =

     0     0     1   110
    -1     0     0     0
     0    -1     0    40
     0     0     0     1



Posici&oacute;n en coordenadas Cartesianas: Pos = [x y z]
 
Pos =
 
[ 110.0, 0, 40.0]
 


Matriz de rotaci&oacute;n:

r =

     0     0     1
    -1     0     0
     0    -1     0



Orientacion en angulos fijos tipo XYZ: fijXYZ = [alpha beta gamma]
   -1.5708         0   -1.5708



Orientacion en angulos de Euler tipo XYZ: eulXYZ = [alpha beta gamma]
         0    1.5708   -1.5708



Orientacion en angulos de Euler tipo ZYZ: eulZYZ = [alpha beta gamma]
         0    1.5708   -1.5708

PULSA CUALQUIER TECLA PARA CONTINUAR


 Evaluacion de A0N con vector de variables Q = [q1 q2 ... qn] 

Q =

    0.5236   -0.5236   -0.2618   -1.5708    3.1416    1.5708


T =

    0.5000    0.6124   -0.6124   34.7474
   -0.8660    0.3536   -0.3536   20.0614
   -0.0000    0.7071    0.7071   10.8579
         0         0         0    1.0000



Posici&oacute;n en coordenadas Cartesianas: Pos = [x y z]
 
Pos =
 
[ 34.747, 20.061, 10.858]
 


Matriz de rotaci&oacute;n:

r =

    0.5000    0.6124   -0.6124
   -0.8660    0.3536   -0.3536
   -0.0000    0.7071    0.7071



Orientacion en angulos fijos tipo XYZ: fijXYZ = [alpha beta gamma]
    0.7854    0.0000   -1.0472



Orientacion en angulos de Euler tipo XYZ: eulXYZ = [alpha beta gamma]
    0.4636   -0.6591   -0.8861



Orientacion en angulos de Euler tipo ZYZ: eulZYZ = [alpha beta gamma]
   -2.6180    0.7854    1.5708

PULSA CUALQUIER TECLA PARA CONTINUAR
</pre><img vspace="5" hspace="5" src="Taller2_04.png" alt=""> <pre class="codeinput"><span class="comment">%Punto 6</span>

clear <span class="string">all</span>
clc

syms <span class="string">L1</span> <span class="string">L2</span> <span class="string">L3</span> <span class="string">L4</span> <span class="string">L5</span> <span class="string">as</span> <span class="string">real</span>
syms <span class="string">q1</span> <span class="string">q2</span> <span class="string">q3</span> <span class="string">q4</span> <span class="string">q5</span> <span class="string">q6</span> <span class="string">as</span> <span class="string">real</span>

P6=[0    0      L1     q1    0     0;
    0   -pi/2   L2     q2   -pi/2  0;
    0   -pi/2   L3     q3    pi/2  0;
    L2   pi/2   0      q4    pi/2  0;
    L4   pi/2   q5     pi/2  L5    1;
    0    pi/2   0      q6    0     0;];

[Robot,L,A0N] = ForKin(P6);

q1=0;
q2=0;
q3=0;
q4=0;
q5=0;
q6=0;

L1=10;
L2=5;
L3=10;
L4=5;
L5=5;

P6=eval(P6);

[Robot,L,A0N] = ForKin(P6);

[N,~]=size(P6);

fprintf(<span class="string">'\n\n Evaluacion de A0N con vector de variables Q = [q1 q2 ... qn] \n'</span>)
Q=zeros(1,Robot.n)
evaluar(A0N, Q);
graficar (Robot,L, Q , 0, 20,10)

disp(<span class="string">'PULSA CUALQUIER TECLA PARA CONTINUAR'</span>);
<span class="comment">%%pause ()</span>
</pre><pre class="codeoutput"> 
Robot = 
 
Robot (6 axis, RRRRPR, modDH, fastRNE)                           
                                                                 
+---+-----------+-----------+-----------+-----------+-----------+
| j |     theta |         d |         a |     alpha |    offset |
+---+-----------+-----------+-----------+-----------+-----------+
|  1|         q1|         L1|          0|          0|          0|
|  2|         q2|         L2|          0|      -pi/2|      -pi/2|
|  3|         q3|         L3|          0|      -pi/2|       pi/2|
|  4|         q4|          0|         L2|       pi/2|       pi/2|
|  5|       pi/2|         q5|         L4|       pi/2|         L5|
|  6|         q6|          0|          0|       pi/2|          0|
+---+-----------+-----------+-----------+-----------+-----------+
                                                                 
grav =    0  base = 1  0  0  0   tool =  1  0  0  0              
          0         0  1  0  0           0  1  0  0              
       9.81         0  0  1  0           0  0  1  0              
                    0  0  0  1           0  0  0  1              
 
 
A01 =
 
[ cos(q1), -1.0*sin(q1),   0,   0]
[ sin(q1),      cos(q1),   0,   0]
[       0,            0, 1.0,  L1]
[       0,            0,   0, 1.0]
 
 
A12 =
 
[ sin(q2),      cos(q2),   0,   0]
[       0,            0, 1.0,  L2]
[ cos(q2), -1.0*sin(q2),   0,   0]
[       0,            0,   0, 1.0]
 
 
A23 =
 
[ -1.0*sin(q3), -1.0*cos(q3),   0,   0]
[            0,            0, 1.0,  L3]
[ -1.0*cos(q3),      sin(q3),   0,   0]
[            0,            0,   0, 1.0]
 
 
A34 =
 
[ -1.0*sin(q4), -1.0*cos(q4),    0,  L2]
[            0,            0, -1.0,   0]
[      cos(q4), -1.0*sin(q4),    0,   0]
[            0,            0,    0, 1.0]
 
 
A45 =
 
[   0, -1.0,    0,                L4]
[   0,    0, -1.0, - 1.0*L5 - 1.0*q5]
[ 1.0,    0,    0,                 0]
[   0,    0,    0,               1.0]
 
 
A56 =
 
[ cos(q6), -1.0*sin(q6),    0,   0]
[       0,            0, -1.0,   0]
[ sin(q6),      cos(q6),    0,   0]
[       0,            0,    0, 1.0]
 
 
A06 =
 
[                       cos(q6)*(sin(q1)*sin(q3) + cos(q1)*cos(q3)*sin(q2)) + sin(q6)*(1.0*cos(q4)*(cos(q3)*sin(q1) - 1.0*cos(q1)*sin(q2)*sin(q3)) + 1.0*cos(q1)*cos(q2)*sin(q4)),                 cos(q6)*(1.0*cos(q4)*(cos(q3)*sin(q1) - 1.0*cos(q1)*sin(q2)*sin(q3)) + 1.0*cos(q1)*cos(q2)*sin(q4)) - 1.0*sin(q6)*(sin(q1)*sin(q3) + cos(q1)*cos(q3)*sin(q2)),     1.0*cos(q1)*cos(q2)*cos(q4) - 1.0*sin(q4)*(cos(q3)*sin(q1) - 1.0*cos(q1)*sin(q2)*sin(q3)),         1.0*L2*(cos(q3)*sin(q1) - 1.0*cos(q1)*sin(q2)*sin(q3)) - 1.0*L4*(1.0*sin(q4)*(cos(q3)*sin(q1) - 1.0*cos(q1)*sin(q2)*sin(q3)) - 1.0*cos(q1)*cos(q2)*cos(q4)) + 1.0*(1.0*L5 + 1.0*q5)*(1.0*cos(q4)*(cos(q3)*sin(q1) - 1.0*cos(q1)*sin(q2)*sin(q3)) + 1.0*cos(q1)*cos(q2)*sin(q4)) - 1.0*L2*sin(q1) + 1.0*L3*cos(q1)*cos(q2)]
[ - 1.0*cos(q6)*(1.0*cos(q1)*sin(q3) - 1.0*cos(q3)*sin(q1)*sin(q2)) - 1.0*sin(q6)*(1.0*cos(q4)*(1.0*cos(q1)*cos(q3) + 1.0*sin(q1)*sin(q2)*sin(q3)) - 1.0*cos(q2)*sin(q1)*sin(q4)), 1.0*sin(q6)*(1.0*cos(q1)*sin(q3) - 1.0*cos(q3)*sin(q1)*sin(q2)) - 1.0*cos(q6)*(1.0*cos(q4)*(1.0*cos(q1)*cos(q3) + 1.0*sin(q1)*sin(q2)*sin(q3)) - 1.0*cos(q2)*sin(q1)*sin(q4)), 1.0*sin(q4)*(1.0*cos(q1)*cos(q3) + 1.0*sin(q1)*sin(q2)*sin(q3)) + 1.0*cos(q2)*cos(q4)*sin(q1), 1.0*L4*(1.0*sin(q4)*(1.0*cos(q1)*cos(q3) + 1.0*sin(q1)*sin(q2)*sin(q3)) + cos(q2)*cos(q4)*sin(q1)) + 1.0*L2*cos(q1) - 1.0*L2*(1.0*cos(q1)*cos(q3) + 1.0*sin(q1)*sin(q2)*sin(q3)) - 1.0*(1.0*cos(q4)*(1.0*cos(q1)*cos(q3) + 1.0*sin(q1)*sin(q2)*sin(q3)) - 1.0*cos(q2)*sin(q1)*sin(q4))*(1.0*L5 + 1.0*q5) + 1.0*L3*cos(q2)*sin(q1)]
[                                                                                       cos(q2)*cos(q3)*cos(q6) - 1.0*sin(q6)*(1.0*sin(q2)*sin(q4) + 1.0*cos(q2)*cos(q4)*sin(q3)),                                                                               - 1.0*cos(q6)*(1.0*sin(q2)*sin(q4) + 1.0*cos(q2)*cos(q4)*sin(q3)) - 1.0*cos(q2)*cos(q3)*sin(q6),                                                 cos(q2)*sin(q3)*sin(q4) - 1.0*cos(q4)*sin(q2),                                                                                                                                                 1.0*L1 - 1.0*(1.0*L5 + 1.0*q5)*(sin(q2)*sin(q4) + cos(q2)*cos(q4)*sin(q3)) - 1.0*L3*sin(q2) - 1.0*L4*(1.0*cos(q4)*sin(q2) - 1.0*cos(q2)*sin(q3)*sin(q4)) - 1.0*L2*cos(q2)*sin(q3)]
[                                                                                                                                                                               0,                                                                                                                                                                             0,                                                                                             0,                                                                                                                                                                                                                                                                                                                               1.0]
 


Posici&oacute;n en coordenadas Cartesianas: Pos = [x y z]'
 
Pos =
 
         1.0*L2*(cos(q3)*sin(q1) - 1.0*cos(q1)*sin(q2)*sin(q3)) - 1.0*L4*(1.0*sin(q4)*(cos(q3)*sin(q1) - 1.0*cos(q1)*sin(q2)*sin(q3)) - 1.0*cos(q1)*cos(q2)*cos(q4)) + 1.0*(1.0*L5 + 1.0*q5)*(1.0*cos(q4)*(cos(q3)*sin(q1) - 1.0*cos(q1)*sin(q2)*sin(q3)) + 1.0*cos(q1)*cos(q2)*sin(q4)) - 1.0*L2*sin(q1) + 1.0*L3*cos(q1)*cos(q2)
 1.0*L4*(1.0*sin(q4)*(1.0*cos(q1)*cos(q3) + 1.0*sin(q1)*sin(q2)*sin(q3)) + cos(q2)*cos(q4)*sin(q1)) + 1.0*L2*cos(q1) - 1.0*L2*(1.0*cos(q1)*cos(q3) + 1.0*sin(q1)*sin(q2)*sin(q3)) - 1.0*(1.0*cos(q4)*(1.0*cos(q1)*cos(q3) + 1.0*sin(q1)*sin(q2)*sin(q3)) - 1.0*cos(q2)*sin(q1)*sin(q4))*(1.0*L5 + 1.0*q5) + 1.0*L3*cos(q2)*sin(q1)
                                                                                                                                                 1.0*L1 - 1.0*(1.0*L5 + 1.0*q5)*(sin(q2)*sin(q4) + cos(q2)*cos(q4)*sin(q3)) - 1.0*L3*sin(q2) - 1.0*L4*(1.0*cos(q4)*sin(q2) - 1.0*cos(q2)*sin(q3)*sin(q4)) - 1.0*L2*cos(q2)*sin(q3)
 


Orientaci&oacute;n en angulos fijos tipo XYZ: fijXYZ = [alpha beta gamma]
 
r31 =
 
cos(q2)*cos(q3)*cos(q6) - 1.0*sin(q6)*(1.0*sin(q2)*sin(q4) + 1.0*cos(q2)*cos(q4)*sin(q3))
 
 
r11 =
 
cos(q6)*(sin(q1)*sin(q3) + cos(q1)*cos(q3)*sin(q2)) + sin(q6)*(1.0*cos(q4)*(cos(q3)*sin(q1) - 1.0*cos(q1)*sin(q2)*sin(q3)) + 1.0*cos(q1)*cos(q2)*sin(q4))
 
 
r21 =
 
- 1.0*cos(q6)*(1.0*cos(q1)*sin(q3) - 1.0*cos(q3)*sin(q1)*sin(q2)) - 1.0*sin(q6)*(1.0*cos(q4)*(1.0*cos(q1)*cos(q3) + 1.0*sin(q1)*sin(q2)*sin(q3)) - 1.0*cos(q2)*sin(q1)*sin(q4))
 
 
r32 =
 
- 1.0*cos(q6)*(1.0*sin(q2)*sin(q4) + 1.0*cos(q2)*cos(q4)*sin(q3)) - 1.0*cos(q2)*cos(q3)*sin(q6)
 
 
r33 =
 
cos(q2)*sin(q3)*sin(q4) - 1.0*cos(q4)*sin(q2)
 
beta = atan2(-r31,sqrt((r11^2)+(r(21^2))))

alpha = atan2(r32/cos(B),r33/cos(B))

gamma = atan2(r21/cos(B),r11/cos(B))



Orientacion en angulos de Euler tipo XYZ: eulXYZ = [alpha beta gamma]
 
r13 =
 
1.0*cos(q1)*cos(q2)*cos(q4) - 1.0*sin(q4)*(cos(q3)*sin(q1) - 1.0*cos(q1)*sin(q2)*sin(q3))
 
 
r23 =
 
1.0*sin(q4)*(1.0*cos(q1)*cos(q3) + 1.0*sin(q1)*sin(q2)*sin(q3)) + 1.0*cos(q2)*cos(q4)*sin(q1)
 
 
r33 =
 
cos(q2)*sin(q3)*sin(q4) - 1.0*cos(q4)*sin(q2)
 
 
r12 =
 
cos(q6)*(1.0*cos(q4)*(cos(q3)*sin(q1) - 1.0*cos(q1)*sin(q2)*sin(q3)) + 1.0*cos(q1)*cos(q2)*sin(q4)) - 1.0*sin(q6)*(sin(q1)*sin(q3) + cos(q1)*cos(q3)*sin(q2))
 
 
r11 =
 
cos(q6)*(sin(q1)*sin(q3) + cos(q1)*cos(q3)*sin(q2)) + sin(q6)*(1.0*cos(q4)*(cos(q3)*sin(q1) - 1.0*cos(q1)*sin(q2)*sin(q3)) + 1.0*cos(q1)*cos(q2)*sin(q4))
 
beta = atan2(r13,sqrt((r23^2)+(r(33^2))))

alpha = atan2(-r23/cos(B),r33/cos(B))

gamma = atan2(-r12/cos(B),r11/cos(B))

 
Robot = 
 
Robot (6 axis, RRRRPR, modDH, fastRNE)                           
                                                                 
+---+-----------+-----------+-----------+-----------+-----------+
| j |     theta |         d |         a |     alpha |    offset |
+---+-----------+-----------+-----------+-----------+-----------+
|  1|         q1|         10|          0|          0|          0|
|  2|         q2|          5|          0|     -1.571|     -1.571|
|  3|         q3|         10|          0|     -1.571|      1.571|
|  4|         q4|          0|          5|      1.571|      1.571|
|  5|      1.571|         q5|          5|      1.571|          5|
|  6|         q6|          0|          0|      1.571|          0|
+---+-----------+-----------+-----------+-----------+-----------+
                                                                 
grav =    0  base = 1  0  0  0   tool =  1  0  0  0              
          0         0  1  0  0           0  1  0  0              
       9.81         0  0  1  0           0  0  1  0              
                    0  0  0  1           0  0  0  1              
 
 
A01 =
 
[ cos(q1), -1.0*sin(q1),   0,    0]
[ sin(q1),      cos(q1),   0,    0]
[       0,            0, 1.0, 10.0]
[       0,            0,   0,  1.0]
 
 
A12 =
 
[ sin(q2),      cos(q2),   0,   0]
[       0,            0, 1.0, 5.0]
[ cos(q2), -1.0*sin(q2),   0,   0]
[       0,            0,   0, 1.0]
 
 
A23 =
 
[ -1.0*sin(q3), -1.0*cos(q3),   0,    0]
[            0,            0, 1.0, 10.0]
[ -1.0*cos(q3),      sin(q3),   0,    0]
[            0,            0,   0,  1.0]
 
 
A34 =
 
[ -1.0*sin(q4), -1.0*cos(q4),    0, 5.0]
[            0,            0, -1.0,   0]
[      cos(q4), -1.0*sin(q4),    0,   0]
[            0,            0,    0, 1.0]
 
 
A45 =
 
[   0, -1.0,    0,            5.0]
[   0,    0, -1.0, - 1.0*q5 - 5.0]
[ 1.0,    0,    0,              0]
[   0,    0,    0,            1.0]
 
 
A56 =
 
[ cos(q6), -1.0*sin(q6),    0,   0]
[       0,            0, -1.0,   0]
[ sin(q6),      cos(q6),    0,   0]
[       0,            0,    0, 1.0]
 
 
A06 =
 
[                       cos(q6)*(sin(q1)*sin(q3) + cos(q1)*cos(q3)*sin(q2)) + sin(q6)*(1.0*cos(q4)*(cos(q3)*sin(q1) - 1.0*cos(q1)*sin(q2)*sin(q3)) + 1.0*cos(q1)*cos(q2)*sin(q4)),                 cos(q6)*(1.0*cos(q4)*(cos(q3)*sin(q1) - 1.0*cos(q1)*sin(q2)*sin(q3)) + 1.0*cos(q1)*cos(q2)*sin(q4)) - 1.0*sin(q6)*(sin(q1)*sin(q3) + cos(q1)*cos(q3)*sin(q2)),     1.0*cos(q1)*cos(q2)*cos(q4) - 1.0*sin(q4)*(cos(q3)*sin(q1) - 1.0*cos(q1)*sin(q2)*sin(q3)),         10.0*cos(q1)*cos(q2) - 5.0*sin(q1) + 5.0*cos(q3)*sin(q1) + 1.0*(1.0*cos(q4)*(cos(q3)*sin(q1) - 1.0*cos(q1)*sin(q2)*sin(q3)) + 1.0*cos(q1)*cos(q2)*sin(q4))*(1.0*q5 + 5.0) - 5.0*sin(q4)*(cos(q3)*sin(q1) - 1.0*cos(q1)*sin(q2)*sin(q3)) + 5.0*cos(q1)*cos(q2)*cos(q4) - 5.0*cos(q1)*sin(q2)*sin(q3)]
[ - 1.0*cos(q6)*(1.0*cos(q1)*sin(q3) - 1.0*cos(q3)*sin(q1)*sin(q2)) - 1.0*sin(q6)*(1.0*cos(q4)*(1.0*cos(q1)*cos(q3) + 1.0*sin(q1)*sin(q2)*sin(q3)) - 1.0*cos(q2)*sin(q1)*sin(q4)), 1.0*sin(q6)*(1.0*cos(q1)*sin(q3) - 1.0*cos(q3)*sin(q1)*sin(q2)) - 1.0*cos(q6)*(1.0*cos(q4)*(1.0*cos(q1)*cos(q3) + 1.0*sin(q1)*sin(q2)*sin(q3)) - 1.0*cos(q2)*sin(q1)*sin(q4)), 1.0*sin(q4)*(1.0*cos(q1)*cos(q3) + 1.0*sin(q1)*sin(q2)*sin(q3)) + 1.0*cos(q2)*cos(q4)*sin(q1), 5.0*cos(q1) - 5.0*cos(q1)*cos(q3) + 10.0*cos(q2)*sin(q1) - 1.0*(1.0*cos(q4)*(1.0*cos(q1)*cos(q3) + 1.0*sin(q1)*sin(q2)*sin(q3)) - 1.0*cos(q2)*sin(q1)*sin(q4))*(1.0*q5 + 5.0) + 5.0*sin(q4)*(1.0*cos(q1)*cos(q3) + 1.0*sin(q1)*sin(q2)*sin(q3)) - 5.0*sin(q1)*sin(q2)*sin(q3) + 5.0*cos(q2)*cos(q4)*sin(q1)]
[                                                                                       cos(q2)*cos(q3)*cos(q6) - 1.0*sin(q6)*(1.0*sin(q2)*sin(q4) + 1.0*cos(q2)*cos(q4)*sin(q3)),                                                                               - 1.0*cos(q6)*(1.0*sin(q2)*sin(q4) + 1.0*cos(q2)*cos(q4)*sin(q3)) - 1.0*cos(q2)*cos(q3)*sin(q6),                                                 cos(q2)*sin(q3)*sin(q4) - 1.0*cos(q4)*sin(q2),                                                                                                                                                  5.0*cos(q2)*sin(q3)*sin(q4) - 5.0*cos(q2)*sin(q3) - 5.0*cos(q4)*sin(q2) - 1.0*(q5 + 5.0)*(sin(q2)*sin(q4) + cos(q2)*cos(q4)*sin(q3)) - 10.0*sin(q2) + 10.0]
[                                                                                                                                                                               0,                                                                                                                                                                             0,                                                                                             0,                                                                                                                                                                                                                                                                                                         1.0]
 


Posici&oacute;n en coordenadas Cartesianas: Pos = [x y z]'
 
Pos =
 
         10.0*cos(q1)*cos(q2) - 5.0*sin(q1) + 5.0*cos(q3)*sin(q1) + 1.0*(1.0*cos(q4)*(cos(q3)*sin(q1) - 1.0*cos(q1)*sin(q2)*sin(q3)) + 1.0*cos(q1)*cos(q2)*sin(q4))*(1.0*q5 + 5.0) - 5.0*sin(q4)*(cos(q3)*sin(q1) - 1.0*cos(q1)*sin(q2)*sin(q3)) + 5.0*cos(q1)*cos(q2)*cos(q4) - 5.0*cos(q1)*sin(q2)*sin(q3)
 5.0*cos(q1) - 5.0*cos(q1)*cos(q3) + 10.0*cos(q2)*sin(q1) - 1.0*(1.0*cos(q4)*(1.0*cos(q1)*cos(q3) + 1.0*sin(q1)*sin(q2)*sin(q3)) - 1.0*cos(q2)*sin(q1)*sin(q4))*(1.0*q5 + 5.0) + 5.0*sin(q4)*(1.0*cos(q1)*cos(q3) + 1.0*sin(q1)*sin(q2)*sin(q3)) - 5.0*sin(q1)*sin(q2)*sin(q3) + 5.0*cos(q2)*cos(q4)*sin(q1)
                                                                                                                                                  5.0*cos(q2)*sin(q3)*sin(q4) - 5.0*cos(q2)*sin(q3) - 5.0*cos(q4)*sin(q2) - 1.0*(q5 + 5.0)*(sin(q2)*sin(q4) + cos(q2)*cos(q4)*sin(q3)) - 10.0*sin(q2) + 10.0
 


Orientaci&oacute;n en angulos fijos tipo XYZ: fijXYZ = [alpha beta gamma]
 
r31 =
 
cos(q2)*cos(q3)*cos(q6) - 1.0*sin(q6)*(1.0*sin(q2)*sin(q4) + 1.0*cos(q2)*cos(q4)*sin(q3))
 
 
r11 =
 
cos(q6)*(sin(q1)*sin(q3) + cos(q1)*cos(q3)*sin(q2)) + sin(q6)*(1.0*cos(q4)*(cos(q3)*sin(q1) - 1.0*cos(q1)*sin(q2)*sin(q3)) + 1.0*cos(q1)*cos(q2)*sin(q4))
 
 
r21 =
 
- 1.0*cos(q6)*(1.0*cos(q1)*sin(q3) - 1.0*cos(q3)*sin(q1)*sin(q2)) - 1.0*sin(q6)*(1.0*cos(q4)*(1.0*cos(q1)*cos(q3) + 1.0*sin(q1)*sin(q2)*sin(q3)) - 1.0*cos(q2)*sin(q1)*sin(q4))
 
 
r32 =
 
- 1.0*cos(q6)*(1.0*sin(q2)*sin(q4) + 1.0*cos(q2)*cos(q4)*sin(q3)) - 1.0*cos(q2)*cos(q3)*sin(q6)
 
 
r33 =
 
cos(q2)*sin(q3)*sin(q4) - 1.0*cos(q4)*sin(q2)
 
beta = atan2(-r31,sqrt((r11^2)+(r(21^2))))

alpha = atan2(r32/cos(B),r33/cos(B))

gamma = atan2(r21/cos(B),r11/cos(B))



Orientacion en angulos de Euler tipo XYZ: eulXYZ = [alpha beta gamma]
 
r13 =
 
1.0*cos(q1)*cos(q2)*cos(q4) - 1.0*sin(q4)*(cos(q3)*sin(q1) - 1.0*cos(q1)*sin(q2)*sin(q3))
 
 
r23 =
 
1.0*sin(q4)*(1.0*cos(q1)*cos(q3) + 1.0*sin(q1)*sin(q2)*sin(q3)) + 1.0*cos(q2)*cos(q4)*sin(q1)
 
 
r33 =
 
cos(q2)*sin(q3)*sin(q4) - 1.0*cos(q4)*sin(q2)
 
 
r12 =
 
cos(q6)*(1.0*cos(q4)*(cos(q3)*sin(q1) - 1.0*cos(q1)*sin(q2)*sin(q3)) + 1.0*cos(q1)*cos(q2)*sin(q4)) - 1.0*sin(q6)*(sin(q1)*sin(q3) + cos(q1)*cos(q3)*sin(q2))
 
 
r11 =
 
cos(q6)*(sin(q1)*sin(q3) + cos(q1)*cos(q3)*sin(q2)) + sin(q6)*(1.0*cos(q4)*(cos(q3)*sin(q1) - 1.0*cos(q1)*sin(q2)*sin(q3)) + 1.0*cos(q1)*cos(q2)*sin(q4))
 
beta = atan2(r13,sqrt((r23^2)+(r(33^2))))

alpha = atan2(-r23/cos(B),r33/cos(B))

gamma = atan2(-r12/cos(B),r11/cos(B))



 Evaluacion de A0N con vector de variables Q = [q1 q2 ... qn] 

Q =

     0     0     0     0     0     0


T =

     0     0     1    15
     0    -1     0    -5
     1     0     0    10
     0     0     0     1



Posici&oacute;n en coordenadas Cartesianas: Pos = [x y z]
 
Pos =
 
[ 15.0, -5.0, 10.0]
 


Matriz de rotaci&oacute;n:

r =

     0     0     1
     0    -1     0
     1     0     0



Orientacion en angulos fijos tipo XYZ: fijXYZ = [alpha beta gamma]
         0   -1.5708   -3.1416



Orientacion en angulos de Euler tipo XYZ: eulXYZ = [alpha beta gamma]
         0    1.5708   -3.1416



Orientacion en angulos de Euler tipo ZYZ: eulZYZ = [alpha beta gamma]
         0    1.5708   -3.1416

PULSA CUALQUIER TECLA PARA CONTINUAR
</pre><img vspace="5" hspace="5" src="Taller2_05.png" alt=""> <pre class="codeinput"><span class="comment">%Punto 7</span>

clear <span class="string">all</span>
clc

syms <span class="string">L1</span> <span class="string">L2</span> <span class="string">L3</span> <span class="string">L6</span> <span class="string">as</span> <span class="string">real</span>
syms <span class="string">q1</span> <span class="string">q2</span> <span class="string">q3</span> <span class="string">q4</span> <span class="string">q5</span> <span class="string">q6</span> <span class="string">as</span> <span class="string">real</span>

P7=[0    0      L1     q1    0     0;
    0   -pi/2   L2     q2   -pi/2  0;
    0    pi/2   q3     pi/2  L3    1;
    0    0      0      q4    0     0;
    0    pi/2   0      q5    0     0;
    0   -pi/2   0      q6    0     0;
    0    0      L6     0     0    -1];


[Robot,L,A0N] = ForKin(P7);

L1=20;
L2=15;
L3=0;
L6=20;


q1=0;
q2=0;
q3=0;
q4=0;
q5=0;
q6=0;

P7=eval(P7);

[Robot,L,A0N] = ForKin(P7);

[N,~]=size(P7);


fprintf(<span class="string">'\n\n Evaluacion de A0N con vector de variables Q = [q1 q2 ... qn] \n'</span>)
Q= zeros(1,Robot.n)
evaluar(A0N, Q);
graficar (Robot,L, Q , 30, 20, 10)

disp(<span class="string">'PULSA CUALQUIER TECLA PARA CONTINUAR'</span>);
pause (5)

fprintf(<span class="string">'\n\n Evaluacion de A0N con vector de variables Q = [q1 q2 ... qn] \n'</span>)
Q=[pi/6, pi/12, 20, 0, pi, pi/2]
evaluar(A0N, Q);
graficar (Robot,L, Q, 30, 20, 10)

disp(<span class="string">'PULSA CUALQUIER TECLA PARA CONTINUAR'</span>);
pause (5)

fprintf(<span class="string">'\n\n Evaluacion de A0N con vector de variables Q = [q1 q2 ... qn] \n'</span>)
Q=[pi/6, -pi/12, 35, 0, 0, pi/2]
evaluar(A0N, Q);
graficar (Robot,L, Q, 30, 20, 10)
</pre><pre class="codeinput"><span class="keyword">function</span> [Rob,l,T] = ForKin(DHpar)

    [N,~] = size(DHpar);
    proof=0;

    <span class="keyword">for</span> i = 1 : N

        <span class="keyword">if</span> DHpar(i,6) == 0
            L(i) = Link(<span class="string">'revolute'</span>,<span class="string">'alpha'</span>,DHpar(i,2),<span class="string">'a'</span>,DHpar(i,1),<span class="string">'d'</span>,DHpar(i,3),<span class="string">'offset'</span>,DHpar(i,5),<span class="string">'qlim'</span>,[-pi pi],<span class="string">'modified'</span>);
        <span class="keyword">elseif</span> DHpar(i,6) == 1
            L(i) = Link(<span class="string">'prismatic'</span>,<span class="string">'alpha'</span>,DHpar(i,2),<span class="string">'a'</span>,DHpar(i,1),<span class="string">'theta'</span>,DHpar(i,4),<span class="string">'offset'</span>,DHpar(i,5),<span class="string">'qlim'</span>,[0, 40],<span class="string">'modified'</span>);
        <span class="keyword">else</span>
            Robot = SerialLink(L,<span class="string">'name'</span>,<span class="string">'Robot'</span>);

            Twt = trotx(DHpar(i,2))*transl(DHpar(i,1),0,0)*<span class="keyword">...</span>
                  trotz(DHpar(i,4))*transl(0,0,DHpar(i,3));

            Twt(isAlways(abs(Twt) &lt;= 1e-10,<span class="string">'Unknown'</span>,<span class="string">'false'</span>) ) = 0;

            Robot.tool = trotx(DHpar(i,2))*transl(DHpar(i,1),0,0)*<span class="keyword">...</span>
                         trotz(DHpar(i,4))*transl(0,0,DHpar(i,3));

            proof=1;
            <span class="keyword">break</span>;
        <span class="keyword">end</span>
    <span class="keyword">end</span>

    <span class="keyword">if</span> proof==0
        Robot = SerialLink(L,<span class="string">'name'</span>,<span class="string">'Robot'</span>);
    <span class="keyword">end</span>

    Robot

    Rob = Robot;

    l=L;

    d1 = digits(5);
    eval(sprintf(<span class="string">'A%d%d = eye(4);'</span>, 0, N));

    <span class="keyword">for</span> i = 1 : N

        <span class="keyword">if</span> i==N &amp;&amp; proof==1
            eval(sprintf(<span class="string">'A%d%d = vpa(simplify(A%d%d*Twt));'</span>, 0, N, 0, N));
            <span class="keyword">break</span>
        <span class="keyword">end</span>
        eval(sprintf(<span class="string">'syms q%d as real'</span>, i));
        eval(sprintf(<span class="string">'A%d%d = vpa(simplify(L(i).A(q%d)));'</span>, i-1, i, i));
        eval(sprintf(<span class="string">'A%d%d(isAlways(abs(A%d%d) &lt;= 1e-10,''Unknown'',''false'')) = 0;'</span><span class="keyword">...</span>
                       , i-1, i, i-1, i))
        <span class="keyword">if</span> L(i).sigma
            eval(sprintf(<span class="string">'Ainter = A%d%d;'</span>, i-1, i));

            eval(sprintf(<span class="string">'q%d = 1;'</span>, i));

            symb = symvar(Ainter);

            <span class="keyword">for</span> j=1 : length(symb)
                eval(strcat(char(symb(1,j)),<span class="string">'=1;'</span>))
            <span class="keyword">end</span>

            Ainter = round(eval(Ainter), 6, <span class="string">'significant'</span>);

            <span class="keyword">for</span> j=1 : 4
                <span class="keyword">for</span> k=1 : 4
                    <span class="keyword">if</span> abs(Ainter(j,k)) &lt;= 1e-10
                        Ainter(j,k) = 0;
                    <span class="keyword">else</span>
                        Ainter(j,k) = 1;
                    <span class="keyword">end</span>
                <span class="keyword">end</span>
            <span class="keyword">end</span>

            eval(sprintf(<span class="string">'A%d%d = vpa(simplify(Ainter.*A%d%d));'</span>, i-1, i, i-1, i));
            eval(sprintf(<span class="string">'syms q%d as real'</span>, i));

            <span class="keyword">for</span> j=1 : length(symb)
                eval([<span class="string">'syms '</span>, char(symb(1,j)),<span class="string">' as real'</span>])
            <span class="keyword">end</span>
        <span class="keyword">end</span>

        eval(sprintf(<span class="string">'A%d%d'</span>, i-1, i))

        eval(sprintf(<span class="string">'A%d%d = vpa(simplify(A%d%d*A%d%d));'</span>, 0, N, 0, N, i-1, i));
    <span class="keyword">end</span>

    <span class="keyword">if</span> proof
        eval(sprintf(<span class="string">'A%d%d = vpa(Twt);'</span>, N-1, N));
        eval(sprintf(<span class="string">'A%d%d'</span>, N-1, N))
    <span class="keyword">end</span>

    eval(sprintf(<span class="string">'T = vpa(simplify(A%d%d));'</span>, 0, N))
    eval(sprintf(<span class="string">'A%d%d'</span>, 0, N))

    <span class="comment">%fkine(Robot)</span>

    fprintf(<span class="string">'\n\nPosici&oacute;n en coordenadas Cartesianas: Pos = [x y z]''\n'</span>)

    Pos = vpa([T(1,4); T(2,4); T(3,4)])

    fprintf(<span class="string">'\n\nOrientaci&oacute;n en angulos fijos tipo XYZ: fijXYZ = [alpha beta gamma]\n'</span>)

    r = T(1:3,1:3);

    r31 = r(3,1)
    r11 = r(1,1)
    r21 = r(2,1)
    r32 = r(3,2)
    r33 = r(3,3)

    fprintf(<span class="string">'beta = atan2(-r31,sqrt((r11^2)+(r(21^2))))\n\n'</span>)
    fprintf(<span class="string">'alpha = atan2(r32/cos(B),r33/cos(B))\n\n'</span>)
    fprintf(<span class="string">'gamma = atan2(r21/cos(B),r11/cos(B))\n\n'</span>)


    fprintf(<span class="string">'\n\nOrientacion en angulos de Euler tipo XYZ: eulXYZ = [alpha beta gamma]\n'</span>)

    r = T(1:3,1:3);

    r13 = r(1,3)
    r23 = r(2,3)
    r33 = r(3,3)
    r12 = r(1,2)
    r11 = r(1,1)

    fprintf(<span class="string">'beta = atan2(r13,sqrt((r23^2)+(r(33^2))))\n\n'</span>)
    fprintf(<span class="string">'alpha = atan2(-r23/cos(B),r33/cos(B))\n\n'</span>)
    fprintf(<span class="string">'gamma = atan2(-r12/cos(B),r11/cos(B))\n\n'</span>)


<span class="keyword">end</span>


<span class="keyword">function</span> T = evaluar(A0N, Q)

    <span class="keyword">for</span> i=1 : length(Q)
        eval(sprintf(<span class="string">'q%d = Q(i);'</span>, i));
    <span class="keyword">end</span>

    T = eval(A0N)

    fprintf(<span class="string">'\n\nPosici&oacute;n en coordenadas Cartesianas: Pos = [x y z]\n'</span>)

    Pos = vpa([T(1,4), T(2,4), T(3,4)])

    fprintf(<span class="string">'\n\nMatriz de rotaci&oacute;n:\n'</span>)

    r = T(1:3,1:3)

    fprintf(<span class="string">'\n\nOrientacion en angulos fijos tipo XYZ: fijXYZ = [alpha beta gamma]\n'</span>)
    fijXYZ = ones(1,3);
    fijXYZ(2) = atan2(-r(3,1),sqrt((r(1,1)^2)+(r(2,1)^2)));

    <span class="keyword">if</span> fijXYZ(2) == pi/2
        fijXYZ(1) = 0;
        fijXYZ(3) = atan2(r(1,2),r(2,2));
    <span class="keyword">elseif</span> fijXYZ(2) == -pi/2
        fijXYZ(1) = 0;
        fijXYZ(3) = -atan2(r(1,2),r(2,2));
    <span class="keyword">else</span>
        fijXYZ(1) = atan2(r(3,2)/cos(fijXYZ(2)),r(3,3)/cos(fijXYZ(2)));
        fijXYZ(3) = atan2(r(2,1)/cos(fijXYZ(2)),r(1,1)/cos(fijXYZ(2)));
    <span class="keyword">end</span>

    disp(fijXYZ)


    fprintf(<span class="string">'\n\nOrientacion en angulos de Euler tipo XYZ: eulXYZ = [alpha beta gamma]\n'</span>)

    eulXYZ = ones(1,3);
    eulXYZ(2) = atan2(r(1,3),sqrt((r(2,3)^2)+(r(3,3)^2)));

    <span class="keyword">if</span> eulXYZ(2) == pi/2
        eulXYZ(1) = 0;
        eulXYZ(3) = atan2(r(2,1),r(2,2));
    <span class="keyword">elseif</span> eulXYZ(2) == -pi/2
        eulXYZ(1) = 0;
        eulXYZ(3) = atan2(r(2,1),r(2,2));
    <span class="keyword">else</span>
        eulXYZ(1) = atan2(-r(2,3)/cos(eulXYZ(2)),r(3,3)/cos(eulXYZ(2)));
        eulXYZ(3) = atan2(-r(1,2)/cos(eulXYZ(2)),r(1,1)/cos(eulXYZ(2)));
    <span class="keyword">end</span>

    disp(eulXYZ)



    fprintf(<span class="string">'\n\nOrientacion en angulos de Euler tipo ZYZ: eulZYZ = [alpha beta gamma]\n'</span>)

    eulZYZ = ones(1,3);
    eulZYZ(2) = atan2(sqrt((r(3,1)^2)+(r(3,2)^2)),r(3,3));

    <span class="keyword">if</span> eulZYZ(2) == 0
        eulZYZ(1) = 0;
        eulZYZ(3) = atan2(-r(1,2),r(1,1));
    <span class="keyword">elseif</span> abs(eulZYZ(2)) == pi || abs(eulZYZ(2)) == -pi
        eulZYZ(1) = 0;
        eulZYZ(3) = atan2(r(1,2),-r(1,1));
    <span class="keyword">else</span>
        eulZYZ(1) = atan2(r(2,3)/sin(eulZYZ(2)),r(1,3)/sin(eulZYZ(2)));
        eulZYZ(3) = atan2(r(3,2)/sin(eulZYZ(2)),-r(3,1)/sin(eulZYZ(2)));
    <span class="keyword">end</span>

    disp(eulZYZ)

<span class="keyword">end</span>


<span class="keyword">function</span> graficar (Robot, L, Q, escala1, escala2, escala3)

    cla();


    tam = (sum(Robot.d)+sum(Robot.a))+escala1;

    trplot(eye(4),<span class="string">'length'</span>,2,<span class="string">'rgb'</span>);
    hold <span class="string">on</span>
    axis([-tam tam -tam tam -tam tam])
    Robot.plot(Q,<span class="string">'workspace'</span>,[-tam tam -tam tam -tam tam],<span class="string">'scale'</span>,0.25);
    <span class="comment">%Robot.teach()</span>

    q_alt = Q;
    M = eye(4);
    Mp = ones(1, Robot.n);
    <span class="keyword">for</span> i=1:Robot.n
        M = M * L(i).A(q_alt(i));
        Mp(i)=trplot(M,<span class="string">'rgb'</span>,<span class="string">'frame'</span>,num2str(i),<span class="string">'length'</span>,escala2,<span class="string">'text_opts'</span>, {<span class="string">'FontSize'</span>, escala3});
    <span class="keyword">end</span>


<span class="keyword">end</span>
</pre><pre class="codeoutput"> 
Robot = 
 
Robot (2 axis, PP, modDH, fastRNE)                               
                                                                 
+---+-----------+-----------+-----------+-----------+-----------+
| j |     theta |         d |         a |     alpha |    offset |
+---+-----------+-----------+-----------+-----------+-----------+
|  1|          0|         q1|          0|          0|          0|
|  2|          0|         q2|          0|      1.571|          0|
+---+-----------+-----------+-----------+-----------+-----------+
                                                                 
grav =    0  base = 1  0  0  0   tool =  1  0  0  0              
          0         0  1  0  0           0  1  0  0              
       9.81         0  0  1  0           0  0  1  0              
                    0  0  0  1           0  0  0  1              
 
 
A01 =
 
[ 1.0,   0,   0,   0]
[   0, 1.0,   0,   0]
[   0,   0, 1.0,  q1]
[   0,   0,   0, 1.0]
 
 
A12 =
 
[ 1.0,   0,    0,       0]
[   0,   0, -1.0, -1.0*q2]
[   0, 1.0,    0,       0]
[   0,   0,    0,     1.0]
 
 
A02 =
 
[ 1.0,   0,    0,       0]
[   0,   0, -1.0, -1.0*q2]
[   0, 1.0,    0,      q1]
[   0,   0,    0,     1.0]
 


Posici&oacute;n en coordenadas Cartesianas: Pos = [x y z]'
 
Pos =
 
       0
 -1.0*q2
      q1
 


Orientaci&oacute;n en angulos fijos tipo XYZ: fijXYZ = [alpha beta gamma]
 
r31 =
 
0
 
 
r11 =
 
1.0
 
 
r21 =
 
0
 
 
r32 =
 
1.0
 
 
r33 =
 
0
 
beta = atan2(-r31,sqrt((r11^2)+(r(21^2))))

alpha = atan2(r32/cos(B),r33/cos(B))

gamma = atan2(r21/cos(B),r11/cos(B))



Orientacion en angulos de Euler tipo XYZ: eulXYZ = [alpha beta gamma]
 
r13 =
 
0
 
 
r23 =
 
-1.0
 
 
r33 =
 
0
 
 
r12 =
 
0
 
 
r11 =
 
1.0
 
beta = atan2(r13,sqrt((r23^2)+(r(33^2))))

alpha = atan2(-r23/cos(B),r33/cos(B))

gamma = atan2(-r12/cos(B),r11/cos(B))



 Evaluacion de A0N con vector  de variables Q = [q1 q2 ... qn] 

Q =

     0     0


T =

     1     0     0     0
     0     0    -1     0
     0     1     0     0
     0     0     0     1



Posici&oacute;n en coordenadas Cartesianas: Pos = [x y z]
 
Pos =
 
[ 0, 0, 0]
 


Matriz de rotaci&oacute;n:

r =

     1     0     0
     0     0    -1
     0     1     0



Orientacion en angulos fijos tipo XYZ: fijXYZ = [alpha beta gamma]
    1.5708         0         0



Orientacion en angulos de Euler tipo XYZ: eulXYZ = [alpha beta gamma]
    1.5708         0         0



Orientacion en angulos de Euler tipo ZYZ: eulZYZ = [alpha beta gamma]
   -1.5708    1.5708    1.5708

PULSA CUALQUIER TECLA PARA CONTINUAR
</pre><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2017a</a><br></p></div><!--
##### SOURCE BEGIN #####



%%
%Punto 2

clear all      
clc

q1=0;
q2=0;
 
P2=[0    0      q1    0    0    1;
    0    pi/2   q2    0    0    1];


[Robot,L,A0N] = ForKin(P2);

fprintf('\n\n Evaluacion de A0N con vector  de variables Q = [q1 q2 ... qn] \n')
Q = zeros(1,Robot.n)
evaluar(A0N, Q);
graficar (Robot,L, Q, 3, 3, 7)

disp('PULSA CUALQUIER TECLA PARA CONTINUAR');
%%pause ()


%%
%Punto 3

clear all 
clc

q1=0;
q2=0;
q3=0;

P3=[0    0       0     q1    0    0;
    0    pi/2    q2    0     0    1;
    0    pi/2    0     q3    0    0];


[Robot,L,A0N] = ForKin(P3);

fprintf('\n\n Evaluacion de A0N con vector de variables Q = [q1 q2 ... qn] \n')
Q = zeros(1,Robot.n)
evaluar(A0N, Q);
graficar (Robot,L, Q, 3, 3, 7)

disp('PULSA CUALQUIER TECLA PARA CONTINUAR');
%pause ()

%%
%Punto 4

clear all 
clc

q1=0;
q2=0;
q3=0;
q4=0;
q5=0;
 
P4=[0           0      1          q1    0      0;
    0           pi/2   q2         0     1      1;
    0           pi/2   1          q3    pi/2   0;
    0          -pi/2   0          q4    pi/4   0;
    sqrt(2)/2   pi/2   sqrt(2)/2  q5   -pi/2   0;
    0          -pi/2   sqrt(2)    0     0     -1];


[Robot,L,A0N] = ForKin(P4);

fprintf('\n\n Evaluacion de A0N con vector de variables Q = [q1 q2 ... qn] \n')
Q = zeros(1,Robot.n)
evaluar(A0N, Q);
graficar (Robot,L, Q, 5, 3, 8)

disp('PULSA CUALQUIER TECLA PARA CONTINUAR');
%pause ()


%%
%Punto 5

clear all 
clc

syms L1 L2 L3 L4 as real 
syms q1 q2 q3 q4 q5 q6 as real 


P5=[0    0      L1     q1   0     0;
    0    pi/2   0      q2   0     0;
    L2   0      0      q3   pi/2  0;
    0    pi/2   L3     q4   pi/2  0;
    0    pi/2   0      q5   0     0;
    0   -pi/2   0      q6   0     0;
    0    0      L4     0    0    -1];


[Robot,L,A0N] = ForKin(P5);

q1=0;
q2=0;
q3=0;
q4=0;
q5=0;
q6=0;

L1=40;
L2=30;
L3=50;
L4=30;

P5=eval(P5);

[Robot,L,A0N] = ForKin(P5);

fprintf('\n\n Evaluacion de A0N con vector de variables Q = [q1 q2 ... qn] \n')
Q= zeros(1,Robot.n)
evaluar(A0N, Q);
graficar (Robot,L, Q, 5, 20, 10)

disp('PULSA CUALQUIER TECLA PARA CONTINUAR');
%pause ()

fprintf('\n\n Evaluacion de A0N con vector de variables Q = [q1 q2 ... qn] \n')
Q=[pi/6, -pi/6, -pi/12, -pi/2, pi, pi/2]
evaluar(A0N, Q);
graficar (Robot,L, Q, 5, 20, 10)

disp('PULSA CUALQUIER TECLA PARA CONTINUAR');
%pause ()



%%
%Punto 6

clear all 
clc

syms L1 L2 L3 L4 L5 as real 
syms q1 q2 q3 q4 q5 q6 as real 

P6=[0    0      L1     q1    0     0;
    0   -pi/2   L2     q2   -pi/2  0;
    0   -pi/2   L3     q3    pi/2  0;
    L2   pi/2   0      q4    pi/2  0;
    L4   pi/2   q5     pi/2  L5    1;
    0    pi/2   0      q6    0     0;];

[Robot,L,A0N] = ForKin(P6);

q1=0;
q2=0;
q3=0;
q4=0;
q5=0;
q6=0;

L1=10;
L2=5;
L3=10;
L4=5;
L5=5;

P6=eval(P6);

[Robot,L,A0N] = ForKin(P6);

[N,~]=size(P6);

fprintf('\n\n Evaluacion de A0N con vector de variables Q = [q1 q2 ... qn] \n')
Q=zeros(1,Robot.n)
evaluar(A0N, Q);
graficar (Robot,L, Q , 0, 20,10)

disp('PULSA CUALQUIER TECLA PARA CONTINUAR');
%%pause ()


%%
%Punto 7

clear all 
clc

syms L1 L2 L3 L6 as real 
syms q1 q2 q3 q4 q5 q6 as real 

P7=[0    0      L1     q1    0     0;
    0   -pi/2   L2     q2   -pi/2  0;
    0    pi/2   q3     pi/2  L3    1;
    0    0      0      q4    0     0;
    0    pi/2   0      q5    0     0;
    0   -pi/2   0      q6    0     0;
    0    0      L6     0     0    -1];

 
[Robot,L,A0N] = ForKin(P7);

L1=20;
L2=15;
L3=0;
L6=20;


q1=0;
q2=0;
q3=0;
q4=0;
q5=0;
q6=0;

P7=eval(P7);

[Robot,L,A0N] = ForKin(P7);

[N,~]=size(P7);


fprintf('\n\n Evaluacion de A0N con vector de variables Q = [q1 q2 ... qn] \n')
Q= zeros(1,Robot.n)
evaluar(A0N, Q);
graficar (Robot,L, Q , 30, 20, 10)

disp('PULSA CUALQUIER TECLA PARA CONTINUAR');
pause (5)

fprintf('\n\n Evaluacion de A0N con vector de variables Q = [q1 q2 ... qn] \n')
Q=[pi/6, pi/12, 20, 0, pi, pi/2]
evaluar(A0N, Q);
graficar (Robot,L, Q, 30, 20, 10)

disp('PULSA CUALQUIER TECLA PARA CONTINUAR');
pause (5)

fprintf('\n\n Evaluacion de A0N con vector de variables Q = [q1 q2 ... qn] \n')
Q=[pi/6, -pi/12, 35, 0, 0, pi/2]
evaluar(A0N, Q);
graficar (Robot,L, Q, 30, 20, 10)


%%
%

function [Rob,l,T] = ForKin(DHpar)

    [N,~] = size(DHpar);
    proof=0;
    
    for i = 1 : N
        
        if DHpar(i,6) == 0
            L(i) = Link('revolute','alpha',DHpar(i,2),'a',DHpar(i,1),'d',DHpar(i,3),'offset',DHpar(i,5),'qlim',[-pi pi],'modified');
        elseif DHpar(i,6) == 1
            L(i) = Link('prismatic','alpha',DHpar(i,2),'a',DHpar(i,1),'theta',DHpar(i,4),'offset',DHpar(i,5),'qlim',[0, 40],'modified');
        else
            Robot = SerialLink(L,'name','Robot');
            
            Twt = trotx(DHpar(i,2))*transl(DHpar(i,1),0,0)*...
                  trotz(DHpar(i,4))*transl(0,0,DHpar(i,3));
              
            Twt(isAlways(abs(Twt) <= 1e-10,'Unknown','false') ) = 0;
            
            Robot.tool = trotx(DHpar(i,2))*transl(DHpar(i,1),0,0)*...
                         trotz(DHpar(i,4))*transl(0,0,DHpar(i,3));
            
            proof=1;
            break;
        end
    end
    
    if proof==0
        Robot = SerialLink(L,'name','Robot');
    end
    
    Robot
    
    Rob = Robot;
    
    l=L;
    
    d1 = digits(5);
    eval(sprintf('A%d%d = eye(4);', 0, N));
    
    for i = 1 : N

        if i==N && proof==1
            eval(sprintf('A%d%d = vpa(simplify(A%d%d*Twt));', 0, N, 0, N));
            break
        end
        eval(sprintf('syms q%d as real', i));
        eval(sprintf('A%d%d = vpa(simplify(L(i).A(q%d)));', i-1, i, i));
        eval(sprintf('A%d%d(isAlways(abs(A%d%d) <= 1e-10,''Unknown'',''false'')) = 0;'...
                       , i-1, i, i-1, i))
        if L(i).sigma
            eval(sprintf('Ainter = A%d%d;', i-1, i));
            
            eval(sprintf('q%d = 1;', i));
            
            symb = symvar(Ainter);
            
            for j=1 : length(symb)
                eval(strcat(char(symb(1,j)),'=1;'))
            end
            
            Ainter = round(eval(Ainter), 6, 'significant');
            
            for j=1 : 4
                for k=1 : 4
                    if abs(Ainter(j,k)) <= 1e-10
                        Ainter(j,k) = 0;
                    else
                        Ainter(j,k) = 1;
                    end
                end
            end
            
            eval(sprintf('A%d%d = vpa(simplify(Ainter.*A%d%d));', i-1, i, i-1, i));
            eval(sprintf('syms q%d as real', i));
            
            for j=1 : length(symb)
                eval(['syms ', char(symb(1,j)),' as real'])
            end
        end
                
        eval(sprintf('A%d%d', i-1, i))
        
        eval(sprintf('A%d%d = vpa(simplify(A%d%d*A%d%d));', 0, N, 0, N, i-1, i));
    end
    
    if proof
        eval(sprintf('A%d%d = vpa(Twt);', N-1, N));
        eval(sprintf('A%d%d', N-1, N))
    end
    
    eval(sprintf('T = vpa(simplify(A%d%d));', 0, N))
    eval(sprintf('A%d%d', 0, N))
    
    %fkine(Robot)
    
    fprintf('\n\nPosición en coordenadas Cartesianas: Pos = [x y z]''\n')
    
    Pos = vpa([T(1,4); T(2,4); T(3,4)])
    
    fprintf('\n\nOrientación en angulos fijos tipo XYZ: fijXYZ = [alpha beta gamma]\n')
    
    r = T(1:3,1:3);
    
    r31 = r(3,1)
    r11 = r(1,1)
    r21 = r(2,1)
    r32 = r(3,2)
    r33 = r(3,3)
    
    fprintf('beta = atan2(-r31,sqrt((r11^2)+(r(21^2))))\n\n')
    fprintf('alpha = atan2(r32/cos(B),r33/cos(B))\n\n')
    fprintf('gamma = atan2(r21/cos(B),r11/cos(B))\n\n')

    
    fprintf('\n\nOrientacion en angulos de Euler tipo XYZ: eulXYZ = [alpha beta gamma]\n')
    
    r = T(1:3,1:3);
    
    r13 = r(1,3)
    r23 = r(2,3)
    r33 = r(3,3)
    r12 = r(1,2)
    r11 = r(1,1)
    
    fprintf('beta = atan2(r13,sqrt((r23^2)+(r(33^2))))\n\n')
    fprintf('alpha = atan2(-r23/cos(B),r33/cos(B))\n\n')
    fprintf('gamma = atan2(-r12/cos(B),r11/cos(B))\n\n')
    
        
end


function T = evaluar(A0N, Q)
    
    for i=1 : length(Q)
        eval(sprintf('q%d = Q(i);', i));
    end
    
    T = eval(A0N)
    
    fprintf('\n\nPosición en coordenadas Cartesianas: Pos = [x y z]\n')
    
    Pos = vpa([T(1,4), T(2,4), T(3,4)])
    
    fprintf('\n\nMatriz de rotación:\n')
    
    r = T(1:3,1:3)
    
    fprintf('\n\nOrientacion en angulos fijos tipo XYZ: fijXYZ = [alpha beta gamma]\n')
    fijXYZ = ones(1,3);
    fijXYZ(2) = atan2(-r(3,1),sqrt((r(1,1)^2)+(r(2,1)^2)));
    
    if fijXYZ(2) == pi/2
        fijXYZ(1) = 0;
        fijXYZ(3) = atan2(r(1,2),r(2,2));
    elseif fijXYZ(2) == -pi/2
        fijXYZ(1) = 0;
        fijXYZ(3) = -atan2(r(1,2),r(2,2));
    else
        fijXYZ(1) = atan2(r(3,2)/cos(fijXYZ(2)),r(3,3)/cos(fijXYZ(2)));    
        fijXYZ(3) = atan2(r(2,1)/cos(fijXYZ(2)),r(1,1)/cos(fijXYZ(2)));
    end
    
    disp(fijXYZ)
    
    
    fprintf('\n\nOrientacion en angulos de Euler tipo XYZ: eulXYZ = [alpha beta gamma]\n')
    
    eulXYZ = ones(1,3);
    eulXYZ(2) = atan2(r(1,3),sqrt((r(2,3)^2)+(r(3,3)^2)));
    
    if eulXYZ(2) == pi/2
        eulXYZ(1) = 0;
        eulXYZ(3) = atan2(r(2,1),r(2,2));
    elseif eulXYZ(2) == -pi/2
        eulXYZ(1) = 0;
        eulXYZ(3) = atan2(r(2,1),r(2,2));
    else
        eulXYZ(1) = atan2(-r(2,3)/cos(eulXYZ(2)),r(3,3)/cos(eulXYZ(2)));    
        eulXYZ(3) = atan2(-r(1,2)/cos(eulXYZ(2)),r(1,1)/cos(eulXYZ(2)));
    end
    
    disp(eulXYZ)
    
    
    
    fprintf('\n\nOrientacion en angulos de Euler tipo ZYZ: eulZYZ = [alpha beta gamma]\n')

    eulZYZ = ones(1,3);
    eulZYZ(2) = atan2(sqrt((r(3,1)^2)+(r(3,2)^2)),r(3,3));
    
    if eulZYZ(2) == 0
        eulZYZ(1) = 0;
        eulZYZ(3) = atan2(-r(1,2),r(1,1));
    elseif abs(eulZYZ(2)) == pi || abs(eulZYZ(2)) == -pi 
        eulZYZ(1) = 0;
        eulZYZ(3) = atan2(r(1,2),-r(1,1));
    else
        eulZYZ(1) = atan2(r(2,3)/sin(eulZYZ(2)),r(1,3)/sin(eulZYZ(2)));    
        eulZYZ(3) = atan2(r(3,2)/sin(eulZYZ(2)),-r(3,1)/sin(eulZYZ(2)));
    end 
    
    disp(eulZYZ)
    
end


function graficar (Robot, L, Q, escala1, escala2, escala3)
    
    cla();
    

    tam = (sum(Robot.d)+sum(Robot.a))+escala1;

    trplot(eye(4),'length',2,'rgb');
    hold on
    axis([-tam tam -tam tam -tam tam])
    Robot.plot(Q,'workspace',[-tam tam -tam tam -tam tam],'scale',0.25);
    %Robot.teach()
    
    q_alt = Q;
    M = eye(4);
    Mp = ones(1, Robot.n);
    for i=1:Robot.n
        M = M * L(i).A(q_alt(i));
        Mp(i)=trplot(M,'rgb','frame',num2str(i),'length',escala2,'text_opts', {'FontSize', escala3});
    end


end



##### SOURCE END #####
--></body></html>